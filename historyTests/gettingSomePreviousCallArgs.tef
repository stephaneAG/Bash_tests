# Follows history stuff & useful reminders on how to get <n> previous call <y> arg(s)
# the last part is definately AWESOME -> "Mind-melting goodness" haha (!) ..

# intro
# adjusting default settings of bash history
# $HISTFILESIZE # how many commands are kept in the history file -> def: 2000
#               => could be made even larger to be examined later ( 10000 )
# $HISTSIZE     # how many are stored in memory for the current session -> def: 1000
#               => could be upgraded to a reasonable cap ( 5000  )
# to preserve the bash history through sessions ( that is, prevent its update overwrite )
shopt -s histappend # histappend setting
# to have bash add cmds to the history instead of waiting the end of each session
# ( aka to enable commands in one terminal to be instantly available in another )
# we can do so by setting or appending the "history -a" cmd to the PROMPT_COMMAND param
# which contains comands executed before each new prompt, R)
# 1: we append to history immediately with history -a, 
# 2: clear the current history in our session with history -c, 
# 3: read the history file that we just append to back into our session history using history -r
# ex:
export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"


# the basic history command
history
# truncate the output
history n
# find all history commands that involve a certain string
history | grep cmd

# scrolling back in history
# instead of using the arrows ( which is actually pretty fine for me)
# we can also use Ctrl-p to move backward in history & Ctrl-n to move forward
# the ALT-Shift stuff doesn't work for me on Ubuntu 14.04 .. yet ?

# searching through bash history
# we can type Ctrl-r, begin typing part of the prev cmd
# if it matches our search, enter, else, use Ctrl-r again to see next result
# don't know yet what Ctrl-s ( to go backward in search ) is mapped to on my current system
# to search using stg already typed at the prompt, we can Ctrl-a, Ctrl-r, Ctrl-y, and Ctrl-r again 
# (CTRL-aryr  -> copyright Justin Ellingwood, the author of one of the articles I stumbled upon => thx, dude ! ;p)

# events designation
# we can execute the last ssh cmd ( that is, the last cmd starting with ssh):
!ssh
# if we're looking for a string that is not at the beginning of a command, we can surround it with "?" chars
# ex, to repeat last apt-cache search cmd
!?search?

# quick search & replace (variation on !!, the last history cmd ), useful for misspellings
#^original^replacement^
# ex:
cat /the/file.texte
^texte^txt^

# words designators
# helps to select a part of a cmd
# ex:
ls /some/dir
cd !!:1 # or cd !1 ( as we're operating on the last cmd )
# R: we can refer to the first arg as "^" & the last as "$"

# ( event designators )
# Execute cmds from the bash history ( the initial purpose of this file, nb)
# the n-th command
!n
# the last command
!! ( or !-1 )
# the last command first argument
!^
# the last command last argument
!$
# last command n-th argument
!:n ( or !!:n )
# last command "invoked stuff"
!!:0

# .. and this is where it gets interesting:
# n-th command last argument
!-1:$
# n-th command y-th argument
!-n:y
# mixing args from two different commands
!-n1:y1!-n2:y2
# get all args from n-th command
!-1:1* ( or !-1:1-$ , or !-1:* , or (silliest way ^^) !-1:^-$)
# get a range of args as so
!-n:a-z # R: != bash's "{a..z}" syntax

# also very useful, ":p" modifier
# echo out stuff instead of trying to call them ( ex with a range of prev args)
!-n:a-z:p
# chop-off head, or tail, or extension
# nb(s): we can use ":r" twice for ex, for ".tar.gz"
# the ":e" modifier is also available & get only the ultimate extension
echo "DIR: !!:$:h:p FILENAME: !!:$:t:p PATH_WITHOUT_EXT: !!:$:r:p FILENAME_WITHOUT_EXT: !!:$:r:t:p"
# other ex
echo "DIR: !!:$:h:p FILENAME: !!:$:t:p EXT: !!:$:e:p PATH_WITHOUT_EXT: !!:$:r:p FILENAME_WITHOUT_EXT: !!:$:r:t:p"
# useful ? sure:
echo lol pffff..
# check what a "recomposed command" 'd look like using ":p"
!!:0:p !!:2:p
# if it looks good to be called ( correct substitution ), hit Ctr-P
# yup, automatically typed ;) => hit enter :D

# history commands substitution
!-n:s/original/new/
# substitute every match by adding the "g" arg to the "s"
touch test1 test2 test3
mkdir !!:*:gs/file/dir/
# or better
touch testFile{1..4}
mkdir !!:*:gs/testFile/testDir/


# TO ADD TO MY ALIASES/FCNS SET
# lclip ( last command to clipboard )
# R:
# echo $HISTSIZE --> 1000
# echo "!!" | xclip -selection c --> echo "echo $HISTSIZE" | xclip -selection c => echo 1000
# history -p '!-1' | xclip -selection c # ok, but interprets the new line & executes stuff if pasted in a term
# history -p '!-1' | tr -d \\n | xclip -selection c # works fine
# Linux
lclip(){ history -p '!!'|tr -d \\n | xclip -selection c; }
# Mac
lclip(){ history -p '!!'|tr -d \\n|pbcopy; }
# Nb: we could check if arg(s) is/are passed to be used as !-n:a-z:m
# aka, if any arg, pass it to history as a replacement for '!!'
# cross platforms
#lclip(){ if [[ "$(uname)" == "Linux" ]]; then history -p '!!'|tr -d \\n | xclip -selection c; else history -p '!!'|tr -d \\n|pbcopy; fi }
#lclip(){ [[ "$(uname)" == "Linux" ]] && history -p '!!'|tr -d \\n | xclip -selection c || history -p '!!'|tr -d \\n|pbcopy }
# shortest
lclip(){ [[ "$(uname)" == "Linux" ]] && clip='xclip -selection c' || clip='pbcopy'; history -p '!!'|tr -d \\n | $clip; }

#cclip (current command to clipboard )
# via Ctrl-] shortcut ( Ctrl-alt gr-] )
# Linux
bind '"\C-]":"\C-e\C-u xclip -selection c <<"EOF"\n\C-y\nEOF\n"'
# Mac
bind '"\C-]":"\C-e\C-u pbcopy <<"EOF"\n\C-y\nEOF\n"'
# cross platforms
cclip(){ [[ "$(uname)" == "Linux" ]] && clip='xclip -selection c' || clip='pbcopy'; bind '"\C-]":"\C-e\C-u $clip <<"EOF"\n\C-y\nEOF\n"'; }
